
## [665. Non-decreasing Array](https://leetcode.com/problems/non-decreasing-array/)
> :black_nib: Ray
### 題目解釋
    能否至多修改一個元素，使陣列符合遞增排序。
### 審題注意
- 根據題幹，最直觀的想法：
    1. 找到不符合元素
    2. 改該個元素
    3. 繼續找下個不符合，再有不符合的代表至少要修改兩次，則回傳 False。
- Greedy Algorithm：
	1. 一個遞增的陣列必定每個子陣列都是符合遞增排序的(這是可以使用貪婪法則的原因)。
	2. 從第 0 個元素開始，逐個增加子陣列長度，並判斷是否符合遞增序列，如果不符合做出修改(如果覺得很抽象，請直接看範例)。
	3. 將問題縮小到怎麼**判斷**及怎麼**修改**。
### 解法(可以直接看結論)
```
判斷是不是遞增很簡單，只要前項比後項大就不符合；
但是怎麼修改就要非常小心，直覺上只要將後項的值改成前項，就可以符合遞增排序了。

Example 1. [1,3,2]
(修改前)
      3 _       [1] => 符合
       / \      [1,3] => 符合
    1 /   2     [1,3,2] => 不符合，修改(將末項改成與前項相同)

(修改後)
      3 _ _     修改後 => [1,3,3] => 符合
       /        只修改一次 => return true
    1 /

上面的例子雖然正確但是擴展到下個例子還是正確嗎？

Example 2. [1,3,2,2]
...(同上)
(修改後)     
      3 _ _     修改後 => [1,3,3] => 符合
       /   \    [1,3,3,2] => 不符合
    1 /     2	已經改過一次 => return false

是不是發現答案有問題？事實上將 [1,3,2,2] 改成 [1,2,2,2] 只要一次修改就符合遞增排序。
所以要針對情況進行修改，而且最保險的改法是讓末項越小越好，原因很簡單，可以再看一次上面的例子。

(修改前)
      3 _       [1] => 符合
       / \ _ _	[1,3] => 符合
    1 /    2 2	[1,3,2] => 不符合，修改

是不是把 [1,3,2] 改成 [1,2,2] 比較保險，但是什麼情況適合這樣改呢？
在腦袋中想像下列哪種情況合適

        (1)                     (2) 
         *                       *
        / \                     / \
       *   \                   /   * (大)
    (前二項) \                 /
             \               /
              * (末項)       * (小)

第(2)種情況適合把前項降到跟末項同值，而這種情況透過判斷前二項是否比末項小。
因為需要判斷到前二項因此要格外小心邊界條件。

    *
     \
      \
       *

當長度只有 2 的時候是沒有前二項的，但是這種情況也屬於把前項降到跟末項同值。

結論就是當發生不符的遞增排序的情況(前項大於後項)：
1. 如果子陣列長度是二(代表沒有前二項)，或或或前二項小於末項，將前項改成末項的值。
2. 否則，將末項改成前項的值。
可以開始打 code 了
```
#### JavaScript (Greedy Algorithm)
```javascript
var checkPossibility = function(nums) {
    for(let i = 1, count = 0; i < nums.length; ++i) {
        if(nums[i - 1] > nums[i]) {
            if(++count === 2) return false
            if(i < 2 || nums[i - 2] < nums[i]) nums[i - 1] = nums[i]
            else nums[i] = nums[i - 1]
        }
    }
    return true
}
```

> 有沒有不修改 input 的方法？
### 解法
```
其實我們只關心每個子陣列的最大值，所以我們只要判斷什麼時候更新最大值。
1. 如果上一個子陣列的最大值比當下的值小或相同(符合遞增排列)，則該子陣列最大值更新為該值。
2. 反之最大值比當下的值大(不符合)，先考慮兩種情況

    (1)                  
        /\
       *  \
    (前二項)\
            \
             * (末項)

    第(1)種情況，不改最大值，回想上一個解法，末項會被改成前項的值，所以最大值還一樣是前項。

    (2)
        /\
       /  * (大)
      /
     /
    * (小)

    第(2)種情況，要改最大值，因為前項會被降到末項的值，意謂著改完後最大值也會降成末項的值。
3. (注意)當沒有前二項，也就是下面這種情況：

    *
     \
      \	  這種情況要更新成末項，因為首項會被降到末項，所以最大值也被降成末項。
       *

結論：當檢視到索引值 2 以上，且且且前二項大於末項時，不更新最大值；其他情況，最大值更新成末值。
```
#### JavaScript (Advanced)
```javascript
var checkPossibility = function(nums) {
    for(let i = 1, prev = nums[0], count = 0; i < nums.length; ++i) {
        if(prev > nums[i]) {
            if(++count === 2) return false
            if(i >= 2 && nums[i - 2] > nums[i]) continue
        }
        prev = nums[i]
    }
    return true
}
```
- 解釋：`prev` 代表之前的最大值，如果 `prev` 比當下的值大，則 `count` 增加，另外判斷是否要更新最大值，如果符合上述解法列出的條件，則跳過(`continue`，不更新)，其他情況就持續更新為末項。

---
